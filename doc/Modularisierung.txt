Die Modularisierung hat zum Ziel, das Projekt in möglichst voneinander unabhängige, verschiedene Funktionsmodule aufzuteilen. Der Gesamtarbeitsumfang teilt sich auf die verschiedenen Module auf, wodurch einzelne Module einfacher zu realisieren sind. Durch eine sinnvolle Aufteilung und erstellen effizienter Schnittstellen wird ebenfalls die Übersichtlichkeit der Lösung verbessert. Weiterhin ist es bei einer entsprechend ausgerichteten Modularisierung möglich, einzelne Module vollständig durch Libraries zu ersetzen. 


Module:

LCD
Die LCD Anzeige wird grösstenteils durch die Arduino-Bibliothek «LiquidCrystal_I2C» abgedeckt. Aufgrund der zeitlichen Vorgaben wird pro Interaktion mit dem Displaycontroller jeweils nur ein Zeichen übermittelt oder der Cursor umpositioniert. Das Modul beinhaltet einen eigenen Speicher, in dem der Soll Display Inhalt abgebildet ist. In regelmässigen Abständen wird durch den Scheduler ein Miniupdate gestartet. Pro Miniupdate wird immer nur ein Zeichen an den Controller gesendet. An bestimmten Stellen erfolgt anstelle der Zeichenübermittlung eine Cursorpositionierung, bspw. vor dem ersten Zeichen. Ein Update des Gesamten LCD auf einmal würde aufgrund der lange dauernden i2c Busaktivität zwischen MC und Displaycontroller länger als 2 ms dauern. Ein Minipdate erfolgt in weniger als 2 ms. Bis der gesamte Display Inhalt (2x16 Zeichen) aktualisiert ist, müssen 34 Miniupdates erfolgen. 


Soundmodul
Das Soundmodul ermöglicht es, dass kontinuierlich ein Ton mit einer gewünschten Frequenz am Lautsprecher ausgegeben wird. Gleichzeitig kann auch ein Tastendruck gemeldet werden. Dabei wird während einer definierte Zeitdauer statt des kontinuierlichen Tons ein Piepston erzeugt. Weil das Soundmodul periodisch über den Scheduler aufgerufen wird, sind die Aufrufintervalle bekannt. Über einen Zähler kann die Dauer des Piepstons kontrolliert werden. Eine erneute Meldung eines Tastendrucks, bevor der vorherige Piepston zu Ende ist, setzt den Zähler wieder zurück und verlängert somit die Gesamtdauer des Piepstons. Ist er beendet, wird wieder der fortlaufende Ton mit der angegebenen Frequenz erzeugt. Die eigentliche Tonerzeugung wird von der Arduinofunktion "tone" übernommen.


KeyRead
Hier wird der analog Eingang der Tester gelesen und anschliessend der ADC Wert in Integerwerte für die entsprechende Taste übersetzt und zurückgemeldet. Mögliche rückgabewerte sind 0 (kein Tastendruck), 1, 2 oder 3. Es findet keine Tastenentprellung statt. Durch die Auslegung der Menustruktur sowie der Tatsache, dass in den Programmen keine Tastendrücke ausser die für das Beenden ausgewertet werden müssen, ergibt sich eine vereinfachte Situation: Eine Taste die in einem der Programmzustände (Menu, Programm 1, Programm 2) gedrückt wird und zu einem Zustandswechsel führt, hat im neuen Zustand keine Funktion. Somit ist eine Entprellung nicht notwendig. 

Scheduler
Der Scheduler wird über eine ISR periodisch aufgerufen. Der Scheduler besitzt mehrere Jobs. Jeder Job hat einen Divisor und eine Bitmaske. Der Divisor hat die Funktion, den Job nicht jedesmal zu berücksichtigen, sondern nur jedes n-te mal. Damit werden auch grössere Intervalle möglich. Wird der Job berücksichtigt, entscheidet das Bit an der Stelle n in der Bitmaske darüber, ob der Job tatsächlich ausgeführt wird oder nicht. Beim nächsten mal entscheidet dann das Bit an der Stelle n+1 etc. Die Bitmaske ist ein Mittel, um sicherzustellen, dass zeitintensive Jobs nie direkt nach einem anderen zeitintensiven Jobs ausgeführt werden: Indem sie den identischen Divisor haben (oder ein ganzzahliges Mehrfaches des anderen Divisors) und im Bitmuster keine einsen an den selben Stellen zu finden sind, wird der Job niemals innerhalb des gleichen Scheduler Aufrufs ausgeführt.


Sensor Vorverarbeitung
Die letzten n Werte werden in einem Array gespeichert, da die Datenauswertung den Wertverlauf über eine Zeit benötigt. Zuerst wird as Array um eine Stelle kopiert, so dass der älteste Wert durch den zweitältesten Wert überschrieben wird etc. Der Sensor wird gelesen und der gelesene Wert geglättet und als neuester Wert ins Array geschrieben. Die Glättung erfolgt, indem nur ein Tei der Differenz zwischen dem letzten gespeicherten Wert im Array und dem aktuell gemessenen Wert addiert wird zum zuletzt gespeicherten Wert.


Datenanalyse
Die Datenanalyse benötigt Daten auseiner eher grösseren Periode, bspw. 1 Sekunde.
Aus den geglätteten Samples wird die Grundfrequenz und Amplitude (peak to peak) bestimmt. Die Amplitude entspricht der Differenz des minimalen zum maximalen Problem: Daten werden laufen aktualisiert, Frequenz errechnung läuft, sobald Zeit vorhanden (falls sie nicht mit mit einem Job erledigt werden kannn)
D.h. während der Analyse wird unterbrochen und inputdaten werden katualisiert, das wird die Analyse verfälschen oder komplett ungültig machen. Lösung: bit wird gesetzt "neue Daten". Am Ende der Analyse wird das Ergebnis nur übernommen, wenn das bit leer ist.Ansosnten bit clearen.
================
fft funktionierte nach test unzuverlässig. problematisch ist die frequenzauflösung, wenn in jedem fall nur die grundwelle gefunden werden soll. ==> neuer Ansatz mit Flankenerkennung: im Signal werden die wechselnden Nulldurchgänge und auch die Min und Max Werte (Peaks) erkannt.
1. DC Offset wird rausgerechnet. uint8 auf int8 cast: wertebereich muss vorgängig begrenzt werden.
2. Nulldurchgänge werden gesucht. Auf einen steigenden Durchgang muss ein sinkender folgend etc. Die Abstände zwischen den Nulldurchgängen werden gespeichert.
3. Peaks werden gesucht. Auf einen Max. muss ein Min folgen. Die Werte müssen mindestens den Hysterese-Abstand zwischeneinander haben. Die Abstände werden gespeichert.
4. Abstände werden sortiert.
5. Eine Art Median der Abstände wird ermittelt. Mittelwert der 3 zentralen Werte, wobei der mittlere doppelt gewichtet wird.
6. Umrechnen in eine Frequenz (ist aktuell die Periodendauer einer Halbwelle in Anzahl samples)
7. Offen: plausibilitätscheck, ansonsten alte frequenz unverändert lassen
8. Offen: LP Filter auf Frequenz legen.











Wert des Arrays. Ermittlung der Frequenz:  
fmin = 0.5 Hz; fmax = 5 Hz

TframeMin = Tfmin = 2 s
fsmin = 2*fmax = 2*5 Hz = 10 Hz, besser 30 Hz machen

30Hz * 2s = 60 Samples. 
30Hz = 1/30 Sekunden Job Intervall
Grundintervall Scheduler = 1 ms
1ms * Divider 33 --> JobIntervall = 0.0303 ms => fsample = 30.3 Hz








